<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectral Point Cloud v12 (Monochrome)</title>
    <!-- FONT: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>
    <style>
        /* --- TASARIM v12: MONOCHROME / GHOST (Şeffaf UI) --- */
        
        :root {
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --bg-color: #000000; 
            --panel-bg: transparent;
            --border-color: transparent; 
            --shadow-color: transparent; 
            
            /* YENİ RENKLER (Tümü Beyaz) */
            --text-primary: #FFFFFF;
            --text-secondary: #AAAAAA;
            --accent-color: #FFFFFF; /* BEYAZ */
            --accent-color-hover: #DDDDDD; /* BEYAZ (Hover) */
            --pause-color: #FFD700; /* Altın Sarısı (Pause için kalsın) */
            --pause-color-hover: #FFA500;
            
            /* Koyu UI Elemanları */
            --slider-track: #444444;
            --input-border: #555555;
            --input-bg: #222222;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: var(--font-sans);
            background: var(--bg-color); 
            color: var(--text-primary); 
            overflow: hidden;
        }
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* --- Panel Temel Stili (Şeffaf) --- */
        .panel {
            position: absolute;
            z-index: 100;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 2px 8px var(--shadow-color);
            padding: 12px;
        }

        /* --- KONTROL PANELİ (SOL ÜST) --- */
        #controls {
            top: 20px;
            left: 20px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .input-wrapper {
            position: relative;
            width: 100%;
        }
        .clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px;
            color: #999;
            cursor: pointer;
            display: none; 
        }
        .clear-btn:hover {
            color: #FFF;
        }
        
        /* --- INPUT, BUTTON (Koyu Tema) --- */
        input[type="file"], input[type="text"], button {
            width: 100%;
            padding: 8px 10px;
            border-radius: 5px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            color: var(--text-primary);
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        input[type="text"] {
            padding-right: 25px; 
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
        }
        
        button {
            background: var(--accent-color);
            color: #000000; /* Siyah yazı (Beyaz buton üzeri) */
            cursor: pointer;
            border: none;
            font-weight: 500;
        }
        button:hover {
            background: var(--accent-color-hover);
        }
        #pauseBtn {
            background: var(--pause-color);
        }
        #pauseBtn:hover {
            background: var(--pause-color-hover);
        }
        #status {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: -4px;
        }
        #progressBarContainer {
            margin-bottom: 2px;
            background: var(--slider-track); /* Arka planı koyu */
            border-radius: 2px;
            height: 4px;
            overflow: hidden;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background: var(--accent-color); /* Beyaz ilerleme */
            transition: width 0.1s linear;
        }

        /* --- BİLGİ KUTUSU (SOL ALT) --- */
        #infoBox {
            bottom: 20px;
            left: 20px;
            z-index: 99;
            padding: 10px 12px;
            font-size: 11px; 
            color: var(--text-secondary);
            line-height: 1.6;
        }
        #infoBox strong {
            color: var(--text-primary);
            font-weight: 500;
        }
        #infoBox span {
            color: #FFFFFF;
            font-weight: 500;
            margin-left: 8px;
        }

        /* --- AYARLAR PANELİ (SAĞ ÜST) --- */
        #settings {
            top: 20px;
            right: 20px;
            min-width: 230px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .setting-group {
            display: flex;
            flex-direction: column;
        }
        .setting-group label {
            margin-bottom: 6px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .setting-group span {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            text-align: right;
        }
        
        /* --- AYIRAÇ --- */
        .settings-divider {
            height: 1px;
            background: var(--slider-track);
            margin: 6px 0;
        }
        
        /* --- ÖZEL SLIDER TASARIMI (Koyu Tema) --- */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 4px;
            background: var(--slider-track);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: var(--accent-color); /* Beyaz tutamaç */
            cursor: pointer;
            border: none; /* Kenarlık kaldırıldı */
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type="range"]::-moz-range-thumb {
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: var(--accent-color); /* Beyaz tutamaç */
            cursor: pointer;
            border: none;
        }

        /* --- ÖZEL CHECKBOX TASARIMI (Koyu Tema) --- */
        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 4px;
        }
        .checkbox-group label {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0;
        }
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 4px;
            border: 1px solid var(--input-border);
            background: var(--input-bg);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }
        input[type="checkbox"]:checked {
            background: var(--accent-color); /* Beyaz kutu */
            border-color: var(--accent-color);
        }
        input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: -2px;
            left: 2px;
            font-size: 12px;
            color: #000; /* Siyah tik */
            font-weight: bold;
        }
        
        /* --- 3D EKRAN ÜSTÜ ETİKETLER --- */
        .label {
            position: absolute;
            color: #FFF;
            font-size: 8px;
            font-family: var(--font-sans);
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
            border: 1px solid #444;
            line-height: 1.4;
        }
        
        /* --- UI GİZLEME/GÖSTERME BUTONU --- */
        #toggleUiBtn { 
            background: var(--input-bg);
            color: var(--text-secondary);
            font-weight: 500;
            border: 1px solid var(--input-border);
            padding: 8px 10px;
            font-size: 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s ease;
            margin-top: 5px;
        }
        #toggleUiBtn:hover {
            background: #333;
            color: #FFF;
        }
        
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- BİLGİ KUTUSU (Artık UI Toggle'ı içeriyor) -->
    <div id="infoBox" class="panel">
        <strong>X-Axis:</strong> Frequency <span id="infoFreq">--</span><br>
        <strong>Y-Axis:</strong> Amplitude <span id="infoAmp">--</span><br>
        <strong>Z-Axis:</strong> Pitch <span id="infoPitch">--</span>
        
        <!-- YENİ UI GİZLEME BUTONU (Buraya taşındı) -->
        <div class="settings-divider"></div>
        <button id="toggleUiBtn">Hide UI</button>
    </div>

    <!-- KONTROLLER -->
    <div id="controls" class="panel">
        <div class="input-wrapper">
            <input type="file" id="fileInput" accept="audio/*">
            <span id="clearFileBtn" class="clear-btn">&times;</span>
        </div>
        <div class="input-wrapper">
            <input type="text" id="urlInput" placeholder="Or paste audio URL">
            <span id="clearUrlBtn" class="clear-btn">&times;</span>
        </div>
        <button id="playBtn">Play</button>
        <button id="pauseBtn" style="display:none;">Pause</button>
        <!-- İLERLEME ÇUBUĞU (Geri geldi) -->
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <div id="status">Load a file or paste a URL</div>
    </div>

    <!-- AYARLAR -->
    <div id="settings" class="panel">
        <!-- Temel Ayarlar -->
        <div class="setting-group">
            <label for="minFreqSlider">Min Frequency (Hz):</label>
            <input type="range" id="minFreqSlider" min="20" max="5000" value="200" step="10">
            <span id="minFreqValue">200 Hz</span>
        </div>
        <div class="setting-group">
            <label for="maxFreqSlider">Max Frequency (Hz):</label>
            <input type="range" id="maxFreqSlider" min="5000" max="20000" value="10000" step="100">
            <span id="maxFreqValue">10000 Hz</span>
        </div>
        <div class="setting-group">
            <label for="amplitudeThresholdSlider">Amplitude Threshold:</label>
            <input type="range" id="amplitudeThresholdSlider" min="0.01" max="0.5" value="0.18" step="0.01">
            <span id="amplitudeThresholdValue">18.0%</span>
        </div>
        <div class="setting-group">
            <label for="maxPeaksSlider">Max Peaks per Sample:</label>
            <input type="range" id="maxPeaksSlider" min="1" max="20" value="5" step="1">
            <span id="maxPeaksValue">5</span>
        </div>
        <div class="setting-group">
            <label for="pointLifetimeSlider">Point Lifetime (seconds):</label>
            <input type="range" id="pointLifetimeSlider" min="5" max="60" value="15" step="1">
            <span id="pointLifetimeValue">15 s</span>
        </div>
        
        <!-- Pozisyon & Hız Ayarları -->
        <div class="settings-divider"></div>
        <!-- YENİ FPS SLIDER'I -->
        <div class="setting-group">
            <label for="sampleFpsSlider">Sample Rate (FPS):</label>
            <input type="range" id="sampleFpsSlider" min="1" max="50" value="15" step="1">
            <span id="sampleFpsValue">15 FPS</span>
        </div>
        <div class="setting-group">
            <label for="verticalScaleSlider">Vertical Scale Multiplier:</label>
            <input type="range" id="verticalScaleSlider" min="0.1" max="10.0" value="1.0" step="0.1">
            <span id="verticalScaleValue">1.0x</span>
        </div>
        <div class="setting-group">
            <label for="connectionDistanceSlider">Connection Distance:</label>
            <input type="range" id="connectionDistanceSlider" min="5" max="50" value="20" step="1">
            <span id="connectionDistanceValue">20</span>
        </div>
        <div class="setting-group">
            <label for="speedSlider">Playback Speed:</label>
            <input type="range" id="speedSlider" min="0.1" max="5.0" value="1.0" step="0.1">
            <span id="speedValue">1.0x</span>
        </div>
        
        <!-- Görünüm Seçenekleri -->
        <div class="settings-divider"></div>
        <div class="checkbox-group">
            <label for="loopToggle">Loop Audio</label>
            <input type="checkbox" id="loopToggle">
        </div>
        <div class="checkbox-group">
            <label for="linesToggle">Show Lines</label>
            <input type="checkbox" id="linesToggle" checked>
        </div>
        <div class="checkbox-group">
            <label for="spiderWebToggle">Enable Spider Web</label>
            <input type="checkbox" id="spiderWebToggle">
        </div>
        <div class="checkbox-group">
            <label for="lightsToggle">Enable Point Lights</label>
            <input type="checkbox" id="lightsToggle">
        </div>
        <div class="setting-group" id="lightIntensityGroup">
            <label for="lightIntensitySlider">Point Light Intensity:</label>
            <input type="range" id="lightIntensitySlider" min="0.1" max="5.0" value="1.2" step="0.1">
            <span id="lightIntensityValue">1.2</span>
        </div>

        <!-- Bloom Ayarları -->
        <div class="settings-divider"></div>
        <div class="setting-group">
            <label style="margin-bottom: 8px; color: var(--text-primary);">Bloom Settings</label>
        </div>
        <div class="setting-group">
            <label for="bloomThresholdSlider">Bloom Threshold:</label>
            <input type="range" id="bloomThresholdSlider" min="0.0" max="1.0" value="0.1" step="0.01">
            <span id="bloomThresholdValue">0.1</span>
        </div>
        <div class="setting-group">
            <label for="bloomStrengthSlider">Bloom Strength:</label>
            <input type="range" id="bloomStrengthSlider" min="0.0" max="3.0" value="1.8" step="0.1">
            <span id="bloomStrengthValue">1.8</span>
        </div>
        <div class="setting-group">
            <label for="bloomRadiusSlider">Bloom Radius:</label>
            <input type="range" id="bloomRadiusSlider" min="0.0" max="2.0" value="0.5" step="0.1">
            <span id="bloomRadiusValue">0.5</span>
        </div>
    </div>

    <!-- THREE.JS & UYGULAMA MANTIĞI -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // SABİT DEĞERLER
        const FFT_SIZE = 4096;
        const BASE_HEIGHT = 40.0; 
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

        // Ayarların ilk değerleri
        let minFrequency = 200;
        let maxFrequency = 10000;
        let amplitudeThreshold = 0.18;
        let lightIntensity = 1.2;
        let maxPeaks = 5;
        let pointLifetime = 15;
        let verticalScale = 1.0; 
        let connectionDistance = 20;
        let loopAudio = false;
        let enablePointLights = false;
        let enableSpiderWeb = false;
        let playbackSpeed = 1.0;
        let enableLines = true;
        let bloomPass; 
        let sampleRateFps = 15; // YENİ FPS DEĞİŞKENİ

        // Slider elemanlarını seç
        const minFreqSlider = document.getElementById('minFreqSlider');
        const maxFreqSlider = document.getElementById('maxFreqSlider');
        const amplitudeThresholdSlider = document.getElementById('amplitudeThresholdSlider');
        const lightIntensitySlider = document.getElementById('lightIntensitySlider');
        const maxPeaksSlider = document.getElementById('maxPeaksSlider');
        const pointLifetimeSlider = document.getElementById('pointLifetimeSlider');
        const verticalScaleSlider = document.getElementById('verticalScaleSlider');
        const connectionDistanceSlider = document.getElementById('connectionDistanceSlider');
        const loopToggle = document.getElementById('loopToggle');
        const lightsToggle = document.getElementById('lightsToggle');
        const lightIntensityGroup = document.getElementById('lightIntensityGroup');
        const spiderWebToggle = document.getElementById('spiderWebToggle');
        const speedSlider = document.getElementById('speedSlider');
        const linesToggle = document.getElementById('linesToggle');
        const bloomThresholdSlider = document.getElementById('bloomThresholdSlider');
        const bloomStrengthSlider = document.getElementById('bloomStrengthSlider');
        const bloomRadiusSlider = document.getElementById('bloomRadiusSlider');
        const sampleFpsSlider = document.getElementById('sampleFpsSlider'); // YENİ

        // Değer etiketlerini seç
        const minFreqValue = document.getElementById('minFreqValue');
        const maxFreqValue = document.getElementById('maxFreqValue');
        const amplitudeThresholdValue = document.getElementById('amplitudeThresholdValue');
        const lightIntensityValue = document.getElementById('lightIntensityValue');
        const maxPeaksValue = document.getElementById('maxPeaksValue');
        const pointLifetimeValue = document.getElementById('pointLifetimeValue');
        const verticalScaleValue = document.getElementById('verticalScaleValue');
        const connectionDistanceValue = document.getElementById('connectionDistanceValue');
        const speedValue = document.getElementById('speedValue');
        const bloomThresholdValue = document.getElementById('bloomThresholdValue');
        const bloomStrengthValue = document.getElementById('bloomStrengthValue');
        const bloomRadiusValue = document.getElementById('bloomRadiusValue');
        const sampleFpsValue = document.getElementById('sampleFpsValue'); // YENİ
        
        const infoFreq = document.getElementById('infoFreq');
        const infoAmp = document.getElementById('infoAmp');
        const infoPitch = document.getElementById('infoPitch');

        // Slider Event Listeners
        minFreqSlider.addEventListener('input', () => {
            minFrequency = parseFloat(minFreqSlider.value);
            minFreqValue.textContent = `${minFrequency} Hz`;
            if (maxFrequency < minFrequency) {
                maxFrequency = minFrequency;
                maxFreqSlider.value = minFrequency;
                maxFreqValue.textContent = `${maxFrequency} Hz`;
            }
        });
        maxFreqSlider.addEventListener('input', () => {
            maxFrequency = parseFloat(maxFreqSlider.value);
            maxFreqValue.textContent = `${maxFrequency} Hz`;
            if (minFrequency > maxFrequency) {
                minFrequency = maxFrequency;
                minFreqSlider.value = maxFrequency;
                minFreqValue.textContent = `${minFrequency} Hz`;
            }
        });
        amplitudeThresholdSlider.addEventListener('input', () => {
            amplitudeThreshold = parseFloat(amplitudeThresholdSlider.value);
            amplitudeThresholdValue.textContent = `${(amplitudeThreshold * 100).toFixed(1)}%`;
        });
        lightIntensitySlider.addEventListener('input', () => {
            lightIntensity = parseFloat(lightIntensitySlider.value);
            lightIntensityValue.textContent = lightIntensity.toFixed(1);
        });
        maxPeaksSlider.addEventListener('input', () => {
            maxPeaks = parseInt(maxPeaksSlider.value);
            maxPeaksValue.textContent = maxPeaks;
        });
        pointLifetimeSlider.addEventListener('input', () => {
            pointLifetime = parseFloat(pointLifetimeSlider.value);
            pointLifetimeValue.textContent = `${pointLifetime} s`;
        });
        verticalScaleSlider.addEventListener('input', () => {
            verticalScale = parseFloat(verticalScaleSlider.value);
            verticalScaleValue.textContent = `${verticalScale.toFixed(1)}x`;
        });
        connectionDistanceSlider.addEventListener('input', () => {
            connectionDistance = parseFloat(connectionDistanceSlider.value);
            connectionDistanceValue.textContent = connectionDistance.toFixed(0);
        });
        speedSlider.addEventListener('input', () => {
            playbackSpeed = parseFloat(speedSlider.value);
            speedValue.textContent = `${playbackSpeed.toFixed(1)}x`;
            if (source) {
                source.playbackRate.setValueAtTime(playbackSpeed, audioContext.currentTime);
            }
        });
        // YENİ FPS SLIDER EVENT'İ
        sampleFpsSlider.addEventListener('input', () => {
            sampleRateFps = parseInt(sampleFpsSlider.value);
            sampleFpsValue.textContent = `${sampleRateFps} FPS`;
        });
        
        // Checkbox Event Listeners
        loopToggle.addEventListener('change', () => {
            loopAudio = loopToggle.checked;
            if (source) {
                source.loop = loopAudio;
            }
        });
        lightsToggle.addEventListener('change', () => {
            enablePointLights = lightsToggle.checked;
            lightIntensitySlider.disabled = !enablePointLights;
            lightIntensityGroup.style.opacity = enablePointLights ? 1.0 : 0.5;
        });
        spiderWebToggle.addEventListener('change', () => {
            enableSpiderWeb = spiderWebToggle.checked;
        });
        linesToggle.addEventListener('change', () => {
            enableLines = linesToggle.checked;
            lines.forEach(l => l.line.visible = enableLines);
        });
        
        // Bloom Slider Event Listeners
        bloomThresholdSlider.addEventListener('input', () => {
            const value = parseFloat(bloomThresholdSlider.value);
            if (bloomPass) bloomPass.threshold = value;
            bloomThresholdValue.textContent = value.toFixed(2);
        });
        bloomStrengthSlider.addEventListener('input', () => {
            const value = parseFloat(bloomStrengthSlider.value);
            if (bloomPass) bloomPass.strength = value;
            bloomStrengthValue.textContent = value.toFixed(1);
        });
        bloomRadiusSlider.addEventListener('input', () => {
            const value = parseFloat(bloomRadiusSlider.value);
            if (bloomPass) bloomPass.radius = value;
            bloomRadiusValue.textContent = value.toFixed(1);
        });

        // Diğer UI Elemanları
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const statusEl = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const clearFileBtn = document.getElementById('clearFileBtn');
        const clearUrlBtn = document.getElementById('clearUrlBtn');
        
        const toggleUiBtn = document.getElementById('toggleUiBtn');
        const controlsPanel = document.getElementById('controls');
        const settingsPanel = document.getElementById('settings');

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000); 
        document.getElementById('container').appendChild(renderer.domElement);

        camera.position.set(25, 15, 35);
        camera.lookAt(0, 0, 0);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Post-processing (Bloom)
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.8, 0.5, 0.1
        );
        composer.addPass(bloomPass);

        // Audio State
        let audioContext, analyser, dataArray, source;
        let isPlaying = false;
        let isPaused = false;
        let startTime = 0;
        let lastSampleTime = 0;
        const points = [];
        const lines = [];

        // Renk Hesaplama
        function getSpectrumColor(frequency) {
            const t = Math.min(Math.max((frequency - minFrequency) / (maxFrequency - minFrequency), 0), 1);
            const color = new THREE.Color();
            const hue = (1 - t) * 0.7; // 0.7 (Mavi/Mor) -> 0.0 (Kırmızı)
            color.setHSL(hue, 1.0, 0.6);
            return color;
        }

        // Tepe Noktalarını Bulma
        function getAllActivePeaks() {
            if (!analyser || !isPlaying || isPaused) return [];
            
            analyser.getByteFrequencyData(dataArray);
            
            const sampleRate = audioContext.sampleRate;
            const binCount = analyser.frequencyBinCount;
            const binFrequency = sampleRate / FFT_SIZE;
            
            const candidatePeaks = [];
            
            for (let i = 5; i < binCount - 5; i++) {
                const frequency = i * binFrequency;
                if (frequency < minFrequency || frequency > maxFrequency) continue;
                
                const amplitude = dataArray[i] / 255.0;
                if (amplitude > amplitudeThreshold) {
                    const isLocalMax = amplitude >= dataArray[i-1] / 255.0 && amplitude >= dataArray[i+1] / 255.0;
                    if (isLocalMax) {
                        const A4 = 440;
                        const midiNote = 12 * Math.log2(frequency / A4) + 69;
                        const pitchClass = ((Math.round(midiNote) % 12) + 12) % 12;
                        
                        candidatePeaks.push({
                            frequency: frequency,
                            amplitude: amplitude,
                            bin: i,
                            pitchClass: pitchClass
                        });
                    }
                }
            }
            
            candidatePeaks.sort((a, b) => b.amplitude - a.amplitude);
            return candidatePeaks.slice(0, maxPeaks);
        }

        // Nokta Oluşturma
        function createPoint(x, y, z, color, amplitude, frequency, emissionTime) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);
            
            let light = null;
            if (enablePointLights) {
                light = new THREE.PointLight(color, lightIntensity, 10);
                light.position.set(x, y, z);
                scene.add(light);
            }
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.style.display = 'none';
            document.body.appendChild(labelDiv);
            
            const point = {
                position: mesh.position,
                color: color.clone(),
                lifetime: pointLifetime,
                initialLifetime: pointLifetime,
                mesh: mesh,
                light: light,
                emissionTime: emissionTime,
                amplitude: amplitude,
                frequency: frequency,
                label: labelDiv
            };
            
            points.push(point);
            
            // Bağlantı Mantığı
            if (enableSpiderWeb) {
                const checkLastN = Math.min(points.length - 1, 100); 
                for (let i = points.length - 2; i > points.length - checkLastN; i--) {
                    if (i < 0) break;
                    const prevPoint = points[i];
                    const dist = prevPoint.position.distanceTo(point.position);
                    if (dist < connectionDistance && dist > 0.1) {
                        createLine(prevPoint, point, color);
                    }
                }
            } else {
                if (points.length > 1) {
                    const prevPoint = points[points.length - 2];
                    const dist = prevPoint.position.distanceTo(point.position);
                    if (dist < connectionDistance && dist > 0.1) {
                        createLine(prevPoint, point, color);
                    }
                }
            }
            return point;
        }

        // Çizgi Oluşturma
        function createLine(startPoint, endPoint, color) {
            if (!enableLines) return; 

            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                startPoint.position,
                endPoint.position
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                linewidth: 2
            });
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.visible = enableLines; 
            scene.add(line);
            
            lines.push({
                line: line,
                tube: null,
                startPoint: startPoint,
                endPoint: endPoint
            });
        }

        // Ses Örnekleme
        function sampleAudio() {
            if (!isPlaying || isPaused || !audioContext) return;
            
            const currentTime = audioContext.currentTime - startTime;
            
            // YENİ FPS DEĞİŞKENİ KULLANILDI
            if (currentTime - lastSampleTime >= 1.0 / sampleRateFps) {
                lastSampleTime = currentTime;
                
                const allPeaks = getAllActivePeaks();
                
                const mainPeak = allPeaks[0];
                if (mainPeak) {
                    infoFreq.textContent = `${mainPeak.frequency.toFixed(0)} Hz`;
                    infoAmp.textContent = `${(mainPeak.amplitude * 100).toFixed(1)}%`;
                    infoPitch.textContent = NOTE_NAMES[mainPeak.pitchClass];
                }
                
                allPeaks.forEach(data => {
                    const logMinFreq = Math.log10(minFrequency > 0 ? minFrequency : 1);
                    const logMaxFreq = Math.log10(maxFrequency);
                    const logCurrentFreq = Math.log10(data.frequency);
                    
                    let logNormalizedFreq = (logCurrentFreq - logMinFreq) / (logMaxFreq - logMinFreq);
                    logNormalizedFreq = Math.min(Math.max(logNormalizedFreq, 0), 1);
                    
                    const x = (logNormalizedFreq * 60 - 30) + (Math.random() - 0.5) * 3;
                    
                    const effectiveHeight = BASE_HEIGHT * verticalScale;
                    const y = (data.amplitude * effectiveHeight - (effectiveHeight / 2)) + (Math.random() - 0.5) * 4;
                    
                    const z = ((data.pitchClass - 6) * 3) + (Math.random() - 0.5) * 5;
                    
                    const color = getSpectrumColor(data.frequency);
                    createPoint(x, y, z, color, data.amplitude, data.frequency, currentTime);
                });
            }
        }

        // Güncellemeler (Solma/Silme)
        function updatePointsAndLines(deltaTime) {
            for (let i = points.length - 1; i >= 0; i--) {
                const point = points[i];
                point.lifetime -= deltaTime;
                const opacity = Math.max(0, point.lifetime / point.initialLifetime);
                point.mesh.material.opacity = opacity;
                if (point.light) {
                    point.light.intensity = opacity * lightIntensity;
                }
                if (point.lifetime <= 0) {
                    scene.remove(point.mesh);
                    point.mesh.geometry.dispose();
                    point.mesh.material.dispose();
                    if (point.light) scene.remove(point.light);
                    document.body.removeChild(point.label);
                    points.splice(i, 1);
                }
            }
            for (let i = lines.length - 1; i >= 0; i--) {
                const lineInfo = lines[i];
                lineInfo.line.visible = enableLines;
                if (!points.includes(lineInfo.startPoint) || !points.includes(lineInfo.endPoint)) {
                    scene.remove(lineInfo.line);
                    lineInfo.line.geometry.dispose();
                    lineInfo.line.material.dispose();
                    lines.splice(i, 1);
                } else if (enableLines) { 
                    const minOpacity = Math.min(
                        lineInfo.startPoint.mesh.material.opacity,
                        lineInfo.endPoint.mesh.material.opacity
                    );
                    lineInfo.line.material.opacity = minOpacity * 0.7;
                }
            }
        }

        // Etiketleri Güncelleme
        function updateLabels() {
            points.forEach(point => {
                const vector = point.position.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y) * 0.5 + 0.5) * window.innerHeight;
                
                const distance = camera.position.distanceTo(point.position);
                const showDist = 15.0;
                const hideDist = 20.0;
                
                if (distance < hideDist && vector.z < 1) {
                    point.label.style.display = 'block';
                    point.label.style.left = x + 'px';
                    point.label.style.top = y + 'px';
                    let opacity = 1.0;
                    if (distance > showDist) {
                        opacity = 1.0 - (distance - showDist) / (hideDist - showDist);
                    }
                    point.label.style.opacity = Math.max(0, Math.min(1, opacity));
                    point.label.innerHTML = `${(point.amplitude * 100).toFixed(1)}%<br>${point.frequency.toFixed(0)}Hz<br>${point.lifetime.toFixed(1)}s`;
                } else {
                    point.label.style.display = 'none';
                }
            });
        }
        
        // Ses motorunu durdurma
        async function resetAudio() {
             if (isPlaying && source) {
                source.onended = null;
                source.stop();
            }
            if (source) source.disconnect();
            if (analyser) analyser.disconnect();
            if (audioContext && audioContext.state !== 'closed') {
                await audioContext.close();
            }
            
            source = null;
            analyser = null;
            
            points.forEach(p => {
                scene.remove(p.mesh);
                if (p.light) scene.remove(p.light);
                document.body.removeChild(p.label);
            });
            lines.forEach(l => scene.remove(l.line));
            points.length = 0;
            lines.length = 0;
            
            isPlaying = false;
            isPaused = false;
            progressBar.style.width = '0%';
            statusEl.textContent = 'Load a file or paste a URL';
            playBtn.disabled = false;
            pauseBtn.style.display = 'none';
            playBtn.style.display = 'block';
            
            infoFreq.textContent = "--";
            infoAmp.textContent = "--";
            infoPitch.textContent = "--";
        }

        // Ses Yükleme
        async function initAudio(sourceType) { 
            
            await resetAudio();
            
            statusEl.textContent = 'Loading...';
            playBtn.disabled = true;

            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.75;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                let audioBuffer;
                
                if (sourceType === 'file') {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    statusEl.textContent = `Playing: ${file.name}`;
                } else if (sourceType === 'url') {
                    statusEl.textContent = 'Fetching from URL...';
                    const response = await fetch(urlInput.value.trim());
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    statusEl.textContent = 'Playing from URL';
                } 
                else if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    statusEl.textContent = `Playing: ${file.name}`;
                } else if (urlInput.value.trim()) {
                    statusEl.textContent = 'Fetching from URL...';
                    const response = await fetch(urlInput.value.trim());
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    statusEl.textContent = 'Playing from URL';
                } else {
                    statusEl.textContent = 'No file or URL provided';
                    playBtn.disabled = false;
                    return;
                }
                
                source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.loop = loopAudio;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                source.playbackRate.setValueAtTime(playbackSpeed, 0);
                source.start(0);
                
                startTime = audioContext.currentTime;
                lastSampleTime = 0;
                isPlaying = true;
                isPaused = false;
                
                playBtn.style.display = 'none';
                pauseBtn.style.display = 'block';
                pauseBtn.textContent = 'Pause';
                playBtn.disabled = false;

                source.onended = () => {
                    isPlaying = false;
                    isPaused = false;
                    playBtn.style.display = 'block';
                    pauseBtn.style.display = 'none';
                    statusEl.textContent = 'Finished. Select a new file.';
                    progressBar.style.width = '0%';
                    infoFreq.textContent = "--";
                    infoAmp.textContent = "--";
                    infoPitch.textContent = "--";
                };

            } catch (error) {
                statusEl.textContent = 'Audio loading error: ' + error.message;
                console.error(error);
                playBtn.disabled = false;
            }
        }

        // Duraklatma/Devam Etme
        function togglePause() {
            if (!audioContext) return;
            if (isPaused) {
                audioContext.resume();
                isPaused = false;
                pauseBtn.textContent = 'Pause';
            } else {
                audioContext.suspend();
                isPaused = true;
                pauseBtn.textContent = 'Resume';
            }
        }

        // Sahne Işıkları
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.2);
        scene.add(ambientLight);
        
        // Ana Render Döngüsü
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            sampleAudio();
            updatePointsAndLines(deltaTime);
            updateLabels();
            
            if (isPlaying && !isPaused && source && source.buffer) {
                const elapsedTime = audioContext.currentTime - startTime;
                const duration = source.buffer.duration;
                const progress = Math.min(elapsedTime / duration, 1);
                progressBar.style.width = (progress * 100) + '%';
            }
            
            controls.update();
            composer.render();
        }

        // Event Listeners
        playBtn.addEventListener('click', () => initAudio()); 
        pauseBtn.addEventListener('click', togglePause);
        
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                urlInput.value = ''; 
                clearUrlBtn.style.display = 'none';
                clearFileBtn.style.display = 'block';
                initAudio('file'); 
            }
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if(urlInput.value.trim()) {
                    fileInput.value = ''; 
                    clearFileBtn.style.display = 'none';
                    clearUrlBtn.style.display = 'block';
                    initAudio('url'); 
                }
            }
        });
        
        clearFileBtn.addEventListener('click', () => {
            fileInput.value = '';
            clearFileBtn.style.display = 'none';
            resetAudio();
        });
        clearUrlBtn.addEventListener('click', () => {
            urlInput.value = '';
            clearUrlBtn.style.display = 'none';
            resetAudio();
        });
        
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI GİZLEME MANTIĞI
        let uiVisible = true;
        toggleUiBtn.addEventListener('click', () => {
            uiVisible = !uiVisible;
            if (uiVisible) {
                controlsPanel.style.display = 'flex';
                settingsPanel.style.display = 'flex';
                toggleUiBtn.textContent = 'Hide UI';
            } else {
                controlsPanel.style.display = 'none';
                settingsPanel.style.display = 'none';
                toggleUiBtn.textContent = 'Show UI';
            }
        });

        // Başlangıçta tüm ayarları tetikle
        [minFreqSlider, maxFreqSlider, amplitudeThresholdSlider, lightIntensitySlider, maxPeaksSlider, pointLifetimeSlider, verticalScaleSlider, connectionDistanceSlider, speedSlider,
         bloomThresholdSlider, bloomStrengthSlider, bloomRadiusSlider,
         sampleFpsSlider // YENİ
        ].forEach(slider => { 
            if(slider) slider.dispatchEvent(new Event('input'));
        });
        
        [loopToggle, lightsToggle, spiderWebToggle, linesToggle
        ].forEach(toggle => {
            if(toggle) toggle.dispatchEvent(new Event('change'));
        });

        // Animasyonu Başlat
        animate();
    </script>
</body>
</html>
