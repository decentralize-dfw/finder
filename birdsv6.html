<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACOUSTIC ARCHITECTURE SYSTEM, Spectral Point Cloud</title>
    
    <!-- Import Map for Three.js -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
        }
    }
    </script>
    
    <!-- CSS Styles -->
    <style>
        /* Font yÃ¼klemeleri (Orijinal) */
        @font-face {
            font-family: 'FakeReceipt';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/OwreKynge.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: '16Segments';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/pixelsix00.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'GuyfordBlackletter';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/GuyfordBlackletter.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Biological';
            src: url('https://raw.githubusercontent.com/decentralize-dfw/font/main/LazenbyCompLiquid.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        /* YENÄ°: Neumorphic Dark "Invert" EstetiÄŸi (Monokrom) */
        :root {
            --bg-color: #1a1a1a; /* Koyu zemin (Invert) */
            --panel-bg: rgba(40, 40, 40, 0.75); /* Koyu Buzlu Cam */
            --panel-border: rgba(120, 120, 120, 0.5); /* YarÄ±-Krom Kenar */
            --panel-shadow: 
                0 0 10px rgba(0, 0, 0, 0.5),
                inset 0 0 5px rgba(0, 0, 0, 0.3);
            
            --control-bg: linear-gradient(145deg, #303030, #282828); /* Koyu Kontrol YÃ¼zeyi */
            --control-border: rgba(80, 80, 90, 0.7);
            
            /* Ã–rneklerdeki gibi iÃ§/dÄ±ÅŸ gÃ¶lgeler (Invert) */
            --shadow-light: rgba(60, 60, 60, 0.7); /* AÃ§Ä±k gÃ¶lge */
            --shadow-dark: rgba(10, 10, 10, 0.8);  /* Koyu gÃ¶lge */

            --text-primary: #e0e0e0;
            --text-secondary: #999999;
            
            --highlight-color: #ffffff; /* Vurgu iÃ§in Beyaz */
            --stop-color: #e0e0e0;
            --stop-color-hover: #ffffff;

            --input-bg: rgba(10, 10, 10, 0.8);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            /* YENÄ°: Ã–rneklerdeki gibi ana font */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            overflow: hidden;
            font-synthesis: none;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        #container { width: 100vw; height: 100vh; position: relative; }

        .panel {
            position: absolute;
            z-index: 100;
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px; /* Daha yuvarlak kÃ¶ÅŸeler */
            box-shadow: var(--panel-shadow);
            padding: 12px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        #controls {
            top: 20px;
            left: 20px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-family: 'Biological', sans-serif;
        }
        
        .input-wrapper { position: relative; width: 100%; }
        
        /* YENÄ°: DÃ¼ÄŸme ve Input Stili (Neumorphic Invert) */
        input[type="text"], button {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px; /* Yuvarlak kÃ¶ÅŸeler */
            border: none;
            background: var(--control-bg);
            color: var(--text-primary);
            font-size: 14px;
            font-family: inherit;
            transition: all 0.1s ease;
            box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light),
                0 0 5px rgba(0,0,0,0.3);
        }

        button {
            cursor: pointer;
            font-weight: 500;
            /* DÃ¼ÄŸmeler dÄ±ÅŸa dÃ¶nÃ¼k */
            box-shadow: 
                3px 3px 5px var(--shadow-dark), 
                -3px -3px 5px var(--shadow-light);
        }
        
        button:hover {
            color: var(--highlight-color);
            box-shadow: 
                3px 3px 5px var(--shadow-dark), 
                -3px -3px 5px var(--shadow-light),
                0 0 10px rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0px);
            /* Aktif olunca iÃ§e dÃ¶nÃ¼k */
            box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light);
        }

        input[type="file"] {
            width: 100%;
            padding: 0;
            border-radius: 10px;
            border: none;
            background: var(--control-bg);
            color: var(--text-secondary);
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s;
            line-height: 2.2; /* Dikey hizalama */
            box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light);
        }
        input[type="file"]::file-selector-button {
            padding: 10px 12px;
            border: none;
            border-right: 1px solid var(--panel-border);
            background: rgba(0,0,0,0.1); /* Hafif farklÄ± */
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-top-left-radius: 9px;
            border-bottom-left-radius: 9px;
            margin-right: 10px;
            transition: background 0.2s ease;
            box-shadow: none;
        }
        input[type="file"]::file-selector-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        input[type="text"] {
            padding-right: 10px;
        }
        input[type="text"]:focus {
            outline: none;
            box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light),
                0 0 0 2px var(--highlight-color); /* Fokus Rengi */
        }
        
        #stopBtn { background: var(--stop-color); color: #000; text-shadow: none; }
        #stopBtn:hover { background: var(--stop-color-hover); }
        
        #removeBtn {
            background: #3a3a44;
            color: var(--text-secondary);
        }
        #removeBtn:hover {
            background: #4a4a54;
            color: #FFF;
        }

        /* Info Paneli Stilleri */
        #infoBtn {
            font-family: 'GuyfordBlackletter', sans-serif;
            font-size: 15px;
            background: var(--control-bg);
            color: var(--text-secondary);
            margin-top: 4px;
        }
        #infoBtn:hover {
            color: #FFF;
        }

        .info-modal-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.85);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            font-family: '16Segments', sans-serif;
            backdrop-filter: blur(5px);
        }
        .info-modal-content {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 30px 40px;
            max-width: 600px;
            width: 90%;
            position: relative;
            color: var(--text-secondary);
            box-shadow: var(--panel-shadow);
        }
         .close-info-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            color: var(--text-secondary);
            background: var(--control-bg);
            border: 1px solid var(--control-border);
            cursor: pointer;
            font-family: sans-serif;
            font-weight: 300;
            line-height: 28px;
            padding: 0;
            width: 30px;
            height: 30px;
            border-radius: 50%; /* Daire */
            text-align: center;
            box-shadow: 
                3px 3px 5px var(--shadow-dark), 
                -3px -3px 5px var(--shadow-light);
        }
        .close-info-btn:hover {
            color: #FFF;
            box-shadow: 
                3px 3px 5px var(--shadow-dark), 
                -3px -3px 5px var(--shadow-light),
                0 0 5px var(--highlight-color);
        }
        .close-info-btn:active {
             box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light);
        }
        /* ... (Info modal iÃ§eriÄŸi deÄŸiÅŸmedi) ... */
        .info-modal-content h2 {
            font-family: 'GuyfordBlackletter', sans-serif;
            color: #FFF;
            font-size: 28px;
            margin-bottom: 5px;
            font-weight: normal;
            text-shadow: 0 0 5px var(--highlight-color);
        }
        .info-modal-content h22 {
            font-family: 'GuyfordBlackletter', sans-serif;
            color: #FFF;
            font-size: 14x;
            margin-bottom: 5px;
            font-weight: normal;
        }
        .info-modal-content h3 {
            font-family: 'Biological', sans-serif;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 20px;
            font-weight: normal;
        }
        .info-modal-content h4 {
            color: #FFF;
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 8px;
        }
        .info-modal-content p {
            font-size: 13px;
            line-height: 1.6;
        }
        .info-modal-content ul {
            list-style-type: none;
            padding-left: 0;
        }
        .info-modal-content li {
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 10px;
        }
        .info-modal-content li strong {
            color: var(--text-primary);
            font-weight: normal;
        }
        .info-footer {
            display: block;
            margin-top: 30px;
            font-family: 'Biological', sans-serif;
            font-size: 14px;
            text-align: right;
            color: var(--text-secondary);
        }
        .info-footer a {
            color: var(--text-secondary);
            text-decoration: none;
            transition: color 0.2s ease;
        }
        .info-footer a:hover {
            color: var(--text-primary);
            text-shadow: 0 0 5px var(--highlight-color);
        }
        
        #status {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: -4px;
            text-shadow: 0 0 2px var(--bg-color);
            text-align: center;
        }
        #progressBarContainer {
            margin-bottom: 2px;
            background: #111;
            border-radius: 4px;
            height: 6px;
            overflow: hidden;
            box-shadow: 
                inset 2px 2px 4px var(--shadow-dark), 
                inset -2px -2px 4px var(--shadow-light);
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background: var(--highlight-color);
            transition: width 0.1s linear;
            border-radius: 4px;
        }
        #infoBox {
            bottom: 20px;
            left: 20px;
            z-index: 99;
            padding: 10px 12px;
            font-size: 15px;
            color: var(--text-secondary);
            line-height: 1.6;
            font-family: 'Biological', sans-serif;
        }
        #infoBox strong { color: var(--text-primary); font-weight: 500; }
        #infoBox span { color: #FFFFFF; font-weight: 500; margin-left: 8px; }
        
        /* YENÄ°: Ayar Paneli Konteyneri (Dikey SÃ¼tunlar iÃ§in) */
        #settingsContainer {
            position: absolute;
            top: 20px;
            right: 20px;
            /* display: flex; // .settings-panel'e taÅŸÄ±ndÄ± */
            max-height: 700px; /* YENÄ°: YÃ¼kseklik SÄ±nÄ±rÄ± */
            z-index: 100;
            /* YENÄ°: Arka plan, border vs kaldÄ±rÄ±ldÄ± (artÄ±k .panel deÄŸil) */
            width: 240px; /* 3 * 80px */
            padding: 0;
            
            /* KaydÄ±rma Ã§ubuÄŸu iÃ§in (ihtiyaÃ§ olursa) */
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--highlight-color) rgba(0,0,0,0.3);
        }
        #settingsContainer::-webkit-scrollbar { width: 8px; }
        #settingsContainer::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 4px; }
        #settingsContainer::-webkit-scrollbar-thumb {
            background-color: var(--highlight-color);
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.5);
        }
        /* KALDIRILDI
        #settingsContainer:hover {
        ...
        */
        .settings-panel {
            position: relative;
            width: 100%; /* Konteynere uysun */
            display: flex;
            flex-direction: row; /* Yatayda baÅŸla */
            flex-wrap: wrap; /* AÅŸaÄŸÄ± kaydÄ±r */
            gap: 0; /* YENÄ°: BoÅŸluk sÄ±fÄ±r, 80*3 tam sÄ±ÄŸsÄ±n */
            align-items: flex-start;
            justify-content: flex-start; /* YENÄ°: Soldan baÅŸla */
            max-height: 100%;
            /* overflow-y: auto; // Ana konteynere taÅŸÄ±ndÄ± */
            font-family: '16Segments', sans-serif;
            padding: 0; /* YENÄ°: Padding kaldÄ±rÄ±ldÄ± */
            /* Scrollbar Stilleri // Ana konteynere taÅŸÄ±ndÄ± */
        }
        /* .settings-panel::-webkit-scrollbar... (Ana konteynere taÅŸÄ±ndÄ±) */

        /* YENÄ°: Dairesel DÃ¼ÄŸme (Knob) Stilleri */
        .knob-container {
            width: 80px; /* Ä°ki sÃ¼tun iÃ§in */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 5px;
            position: relative;
        }
        .knob {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--control-bg);
            box-shadow: 
                5px 5px 10px var(--shadow-dark), 
                -5px -5px 10px var(--shadow-light);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: ns-resize; /* Dikey sÃ¼rÃ¼kleme */
            transition: box-shadow 0.1s ease;
            position: relative; /* YENÄ°: Dolgu iÃ§in eklendi */
            overflow: hidden; /* YENÄ°: Dolgu iÃ§in eklendi */
        }
        .knob:active {
            box-shadow: 
                inset 5px 5px 10px var(--shadow-dark), 
                inset -5px -5px 10px var(--shadow-light),
                inset -5px -5px 10px var(--shadow-light);
        }
        .knob-icon {
            width: 16px;
            height: 16px;
            stroke: var(--text-primary);
            filter: drop-shadow(0 0 3px var(--highlight-color));
            pointer-events: none;
            position: relative; /* YENÄ°: Dolgunun Ã¼stÃ¼nde kalmasÄ± iÃ§in */
            z-index: 2; /* YENÄ°: Dolgunun Ã¼stÃ¼nde kalmasÄ± iÃ§in */
            /* DÃ¶nÃ¼ÅŸ JS ile ayarlanacak - ARTIK DÃ–NMEYECEK */
        }
        .knob-label {
            font-family: '16Segments', sans-serif;
            font-size: 7px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-top: 4px;
            cursor: help; /* Bilgi iÃ§in */
            text-align: center;
        }
        .knob-label:hover {
            color: #FFF;
            text-shadow: 0 0 5px var(--highlight-color);
        }
        .knob-value {
            font-family: '16Segments', sans-serif;
            font-size: 8px;
            color: var(--text-primary);
            margin-top: 2px;
        }

        /* YENÄ°: DÃ¼ÄŸme Dolgusu */
        .knob-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%; /* JS ile kontrol edilecek */
            background: var(--highlight-color);
            opacity: 0.375;
            z-index: 1;
            /* transition: height 0.05s linear; // SÃ¼rÃ¼klerken takÄ±lma yapmamasÄ± iÃ§in kaldÄ±rÄ±ldÄ± */
            pointer-events: none;
        }

        /* AyÄ±rÄ±cÄ± Stili (KALDIRILDI) */
        /*
        .settings-divider {
            height: 1px;
            width: 100%;
            background: var(--panel-border);
            margin: 5px 0;
            opacity: 0.5;
        }
        */
        
        /* Checkbox Stilleri */
        .checkbox-group {
            width: 100%; /* Panelin tamamÄ±nÄ± kapla */
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 2px;
            padding: 3px 8px;
        }
        .checkbox-group label {
            font-size: 9px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0;
            cursor: help; /* Bilgi iÃ§in */
        }
        .checkbox-group label:hover {
             color: #FFF;
            text-shadow: 0 0 5px var(--highlight-color);
        }
        
        input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            width: 30px; /* Ã–rnekteki gibi daha geniÅŸ */
            height: 15px;
            border-radius: 10px;
            border: none;
            background: var(--control-bg);
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            flex-shrink: 0;
            box-shadow: 
                inset 3px 3px 5px var(--shadow-dark), 
                inset -3px -3px 5px var(--shadow-light);
        }
        /* Checkbox DÃ¼ÄŸmesi */
        input[type="checkbox"]::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 11px;
            height: 11px;
            border-radius: 50%;
            background: linear-gradient(145deg, #ddd, #aaa);
            box-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            transition: all 0.2s ease;
        }
        
        input[type="checkbox"]:checked {
            background: var(--highlight-color);
            box-shadow: 
                inset 2px 2px 4px rgba(0,0,0,0.3), 
                inset -2px -2px 4px rgba(255,255,255,0.2),
                0 0 10px var(--highlight-color);
        }
        input[type="checkbox"]:checked::before {
            transform: translateX(15px);
            background: #1a1a1a; /* Koyu tutamaÃ§ */
        }
        
        .label {
            position: absolute;
            color: #FFF;
            font-size: 8px;
            font-family: sans-serif;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            border-radius: 3px;
            white-space: nowrap;
            border: 1px solid #444;
            line-height: 1.4;
            transform: translate(10px, -50%);
            z-index: 1001; /* Etiketlerin Ã¼stÃ¼nde */
        }
        #toggleUiBtn {
            font-weight: 500;
            padding: 10px 12px;
            font-size: 13px;
            margin-top: 5px;
        }
        #gizmoContainer { display: none; }

        /* YENÄ°: Ayar Bilgisi Tooltip'i */
        #tooltip {
            position: absolute;
            z-index: 1010;
            background: #000;
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            padding: 6px 10px;
            width: 200px;
            font-family: '16Segments', sans-serif;
            font-size: 10px;
            line-height: 1.5;
            color: var(--text-primary);
            display: none; /* JS ile gÃ¶sterilecek */
            pointer-events: none; /* TÄ±klamayÄ± engellemesin */
        }
        #tooltip p {
            margin: 0;
            padding: 0;
        }

    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Info Box (Sol Alt) -->
    <div id="infoBox" class="panel">
        <strong>X-Axis:</strong> Frequency <span id="infoFreq">--</span><br>
        <strong>Y-Axis:</strong> Amplitude <span id="infoAmp">--</span><br>
        <strong>Z-Axis:</strong> Timbre (Harm) <span id="infoTimbre">--</span>
        <div class="settings-divider"></div>
        <button id="toggleUiBtn">Hide UI</button>
        <button id="infoBtn">[INFO]</button>
    </div>

    <!-- Kontroller (Sol Ãœst) -->
    <div id="controls" class="panel">
        <div class="input-wrapper">
            <input type="file" id="fileInput" accept="audio/*">
        </div>
        <div class="input-wrapper">
            <input type="text" id="urlInput" placeholder="Or paste audio URL">
        </div>
        <button id="playBtn">Play</button>
        <button id="stopBtn" style="display:none;">Stop</button>
        <button id="removeBtn">Remove</button>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <div id="status">Load a file or paste a URL</div>
    </div>

    <!-- YENÄ°: Ayarlar (SaÄŸ Ãœst) - Dairesel DÃ¼ÄŸmelerle doldurulacak -->
    <!-- YENÄ°: .panel sÄ±nÄ±fÄ± kaldÄ±rÄ±ldÄ± -->
    <div id="settingsContainer" class="settings-panel">
        <!-- DÃ¼ÄŸmeler JS ile buraya eklenecek -->
        <!-- 
            HTML'den kaldÄ±rÄ±ldÄ±:
            <div id="visualSettings" class="panel settings-panel"></div>
            <div id="soundSettings" class="panel settings-panel"></div>
        -->
    </div>

    <!-- Info Modal (Genel Bilgi) -->
    <div id="infoModal" class="info-modal-container">
        <div class="info-modal-content">
            <button id="closeInfoBtn" class="close-info-btn">&times;</button>
            
            <h2>[ Acoustic Architecture System ]</h2>
            <p>Each sound particle is positioned in 3D space according to 6 primary parameters:</p>
            
            <h4>1. SPATIAL AXES (X, Y, Z)</h4>
            <ul>
                <li><strong>X-AXIS (Frequency):</strong> Defines the "tonal space" of the sound. Low frequencies (bass) are on the left, high frequencies (treble) are on the right.</li>
                <li><strong>Y-AXIS (Amplitude):</strong> Defines the "power" or "volume" of the sound. High amplitude (loud) sounds move higher up the Y-axis.</li>
                <li><strong>Z-AXIS (Timbre):</strong> Defines the "timbral richness." Pure sounds (sine waves, flutes) are near the front (low Z), while harmonically rich sounds (piano, vocals, distortion) are placed deeper along the Z-axis.</li>
            </ul>
            
            <h4>2. VISUAL PROPERTIES</h4>
            <ul>
                <li><strong>COLOR (Hue):</strong> Represents the "musical identity" (Pitch Class) using a 12-note color wheel (e.g., C=Red, D=Yellow, E=Green...). Can be globally adjusted.</li>
                <li><strong>SCALE (Size):</strong> Reflects the "volume" (Amplitude). Louder sounds (higher on the Y-Axis) also create larger particles.</li>
                <li><strong>BRIGHTNESS (Bloom):</strong> The sound's power and brilliance create a glow effect, controlled by the "Bloom" settings (top-right menu).</li>
            </ul>
            
            <span class="info-footer">
              <span class="info-footer"><h22>Virtually Ever After,<h22><p>2025, <br>
                <a href="https://www.virtuallyeverafter.xyz/" target="_blank">ðŸ”—website</a>
              </span>
        </div>
    </div>

    <!-- YENÄ°: TÄ±klanabilir Ayar Bilgisi Tooltip'i -->
    <div id="tooltip"></div>


    <!-- THREE.JS & UYGULAMA MANTIÄžI -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // SABÄ°T DEÄžERLER
        const FFT_SIZE = 8192;
        const BASE_X_WIDTH = 60.0;
        const BASE_Y_HEIGHT = 40.0;
        const BASE_Z_DEPTH = 50.0;
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const A4_FREQ = 440.0;
        
        // Gerekli fonksiyonu erken tanÄ±mla
        function getNoteName(midi) {
            const octave = Math.floor(midi / 12) - 1;
            return NOTE_NAMES[midi % 12] + octave;
        }

        // YENÄ°: Global Ayar DeÄŸiÅŸkenleri (VarsayÄ±lan DeÄŸerler GÃ¼ncellendi)
        window.minFrequency = 20;
        window.maxFrequency = 20000;
        window.xAxisScale = 2.14;
        window.yAxisSensibility = 1.0; 
        window.xAxisSensibility = 1.0;
        window.amplitudeThreshold = 0.5;
        window.maxPeaks = 2;
        window.pointLifetime = 10;
        window.verticalScale = 2.82;
        window.zAxisScale = 2.24;
        window.harmonicSensitivity = 0.31;
        window.pitchRangeMin = 21;
        window.pitchRangeMax = 96;
        window.pointScale = 0.74;
        window.loopAudio = false;
        window.playbackSpeed = 1.0;
        window.enableLines = true;
        window.enableSimultaneousConnections = false;
        window.connectionDistance = 457;
        window.sampleRateFps = 15;
        // Ã‡izgi kalÄ±nlÄ±ÄŸÄ± kaldÄ±rÄ±ldÄ±
        window.hueOffset = 0.0;
        window.saturation = 1.0;
        window.lightness = 0.6;
        window.autoRotateSpeed = 0.0;
        window.bloomThreshold = 0.04;
        window.bloomStrength = 1.8;
        window.bloomRadius = 0.7;


        // Peak tracking
        let previousPeaks = [];
        const peakTrackingTolerance = 1.0;
        const spectralMaskingHz = 100;

        // YENÄ°: DÃ¼ÄŸme Ä°konlarÄ± (SVG)
        const ICONS = {
            xAxisScale: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 12h16m-4-4l4 4-4 4m-8-4l-4 4 4 4"/>`,
            xAxisSensibility: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 12c0-4.5 3-8 8-8s8 3.5 8 8-3 8-8 8"/>`,
            verticalScale: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 4v16m-4-4l4 4 4-4m-4-8l-4 4 4 4"/>`,
            yAxisSensibility: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 21c-4.5 0-8-3-8-8s3.5-8 8-8 8 3 8 8"/>`,
            zAxisScale: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 12l8-8 8 8-8 8-8-8zm8-8v16"/>`,
            pointScale: `<circle cx="12" cy="12" r="8" stroke-width="1.5" fill="none"/>`,
            hueOffset: `<circle cx="12" cy="12" r="8" stroke-width="1.5" fill="none"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 4v2m0 12v2m8-8h-2M6 12H4m6-6l-1.5-1.5M13.5 13.5l1.5 1.5M10.5 13.5l-1.5 1.5M13.5 10.5l1.5-1.5"/>`,
            saturation: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 21.5c-5.25 0-9.5-4.25-9.5-9.5S6.75 2.5 12 2.5M12 2.5v19"/>`, // YarÄ±m dolu
            lightness: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 4v16m-6.364-6.364L16.95 5.05m-1.899 13.899L6.364 10.364m0 3.272L16.95 8.322m-1.899 7.35l-8.687-8.686"/>`, // ParlaklÄ±k
            bloomThreshold: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 2v4m0 12v4m-9-9H1m18 0h-2m-6.5-6.5l-3-3m11 11l-3-3m0-8l3-3m-11 11l3-3"/>`, // KÄ±vÄ±lcÄ±m
            bloomStrength: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 2v4m0 12v4m-9-9H1m18 0h-2m-6.5-6.5l-3-3m11 11l-3-3m0-8l3-3m-11 11l3-3m-1 1l-2-2 2 2zM12 8a4 4 0 100 8 4 4 0 000-8z"/>`, // GÃ¼Ã§lÃ¼ KÄ±vÄ±lcÄ±m
            bloomRadius: `<circle cx="12" cy="12" r="3" stroke-width="1.5" fill="none"/><path stroke-width="1.5" d="M12 4.5a7.5 7.5 0 000 15 7.5 7.5 0 000-15z" stroke-opacity="0.5"/><path stroke-width="1.5" d="M12 2a10 10 0 000 20 10 10 0 000-20z" stroke-opacity="0.2"/>`,
            minFreq: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 12h3l3 7 6-14 3 7h3"/>`, // DÃ¼ÅŸÃ¼k frekans
            maxFreq: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 12h2l1 4 2-8 2 8 1-4h2"/>`, // YÃ¼ksek frekans
            amplitudeThreshold: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 12h16m-4 4l-4-4-4 4"/>`, // EÅŸik
            harmonicSensitivity: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 12h3l2 5 2-10 2 10 2-5h3m-9-3s0-2-2-2m4 0s0 2 2 2"/>`, // Harmonikler
            pitchRangeMin: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 18v-8m3 8V6m3 12v-5m3 5v-8"/>`, // DÃ¼ÅŸÃ¼k nota
            pitchRangeMax: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 18V6m3 12v-8m3 8v-5m3 5V6"/>`, // YÃ¼ksek nota
            maxPeaks: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 18l6-10 4 6 5-10 3 6"/>`, // Tepeler
            pointLifetime: `<circle cx="12" cy="12" r="8" stroke-width="1.5" fill="none"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6v6l4 2"/>`, // Saat
            sampleFps: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4h16v16H4V4zm0 6h16M0 10h4m16 0h4"/>`, // Film ÅŸeridi
            speed: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M5 18l6-6-6-6m7 12l6-6-6-6"/>`, // Ä°leri sar
            autoRotateSpeed: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 4a8 8 0 106.364 3.636M12 4V0m0 4l4-4"/>`, // DÃ¶ndÃ¼rme
            loop: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 4v5h5M4 9a8 8 0 106.364 3.636M20 20v-5h-5M20 15a8 8 0 00-6.364-3.636"/>`, // Loop
            connectionDistance: `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12h12M7 17l-4-5 4-5M17 17l4-5-4-5"/>` // BaÄŸlantÄ±
        };

        // YENÄ°: DÃ¼ÄŸme Kontrol KonfigÃ¼rasyonu (TEK LÄ°STE)
        const ALL_CONTROLS_CONFIG = [
            // Group 1: Scale
            { type: 'knob', id: 'xAxisScale', min: -1, max: 1, value: 0.33, log: true, suffix: 'x', var: 'xAxisScale', label: 'X-Axis Scale', info: 'VISUAL: Stretches or compresses the horizontal (X-Axis) spread of frequencies.' },
            { type: 'knob', id: 'verticalScale', min: -1, max: 1, value: 0.45, log: true, suffix: 'x', var: 'verticalScale', label: 'Y-Axis Scale', info: 'VISUAL: Multiplies the effect of volume (Amplitude) on the Y-Axis (height).' },
            { type: 'knob', id: 'zAxisScale', min: -1, max: 1, value: 0.35, log: true, suffix: 'x', var: 'zAxisScale', label: 'Z-Axis Scale', info: 'VISUAL: Stretches or compresses the depth (Z-Axis) of the Timbre (Harmonic Richness).' },
            { type: 'knob', id: 'pointScale', min: -1, max: 1, value: -0.13, log: true, suffix: 'x', var: 'pointScale', label: 'Base Point Scale', info: 'VISUAL: Sets the base size of the points. Final size is (Base * Amplitude).' },
            
            /* { type: 'divider' }, // KALDIRILDI */

            // Group 2: Sensibility
            { type: 'knob', id: 'xAxisSensibility', min: 0.1, max: 3.0, value: 1.0, log: false, suffix: '', step: 0.01, var: 'xAxisSensibility', label: 'X-Axis Sensibility', info: 'VISUAL: Controls the logarithmic mapping of frequency. <1 biases low, >1 biases high.' },
            { type: 'knob', id: 'yAxisSensibility', min: 0.1, max: 3.0, value: 1.0, log: false, suffix: '', step: 0.01, var: 'yAxisSensibility', label: 'Y-Axis Sensibility', info: 'VISUAL: Controls the power mapping of amplitude. <1 biases low, >1 biases high.' },
            { type: 'knob', id: 'harmonicSensitivity', min: 0, max: 2, value: 0.31, log: false, suffix: '', step: 0.01, var: 'harmonicSensitivity', label: 'Timbre Sensitivity', info: 'VISUAL: How strongly harmonics (tÄ±nÄ±) affect the Z-Axis depth.' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 3: Freq/Amp Filters
            { type: 'knob', id: 'minFreq', min: 20, max: 5000, value: 20, log: false, suffix: ' Hz', step: 10, var: 'minFrequency', label: 'Min Frequency', info: 'FILTER: The lowest frequency to visualize (X-Axis left limit).' },
            { type: 'knob', id: 'maxFreq', min: 5000, max: 20000, value: 20000, log: false, suffix: ' Hz', step: 100, var: 'maxFrequency', label: 'Max Frequency', info: 'FILTER: The highest frequency to visualize (X-Axis right limit).' },
            { type: 'knob', id: 'amplitudeThreshold', min: 0.1, max: 0.5, value: 0.5, log: false, suffix: '%', step: 0.01, var: 'amplitudeThreshold', label: 'Amplitude Threshold', info: 'FILTER: The minimum volume (0-1) required to create a point (Y-Axis bottom limit).' },
            
            /* { type: 'divider' }, // KALDIRILDI */

            // Group 4: Pitch Filters
            { type: 'knob', id: 'pitchRangeMin', min: 21, max: 80, value: 21, log: false, suffix: '', step: 1, var: 'pitchRangeMin', label: 'Min Pitch Filter', info: 'FILTER: The lowest note (MIDI) to display (e.g., 21 = A0).' },
            { type: 'knob', id: 'pitchRangeMax', min: 81, max: 108, value: 96, log: false, suffix: '', step: 1, var: 'pitchRangeMax', label: 'Max Pitch Filter', info: 'FILTER: The highest note (MIDI) to display (e.g., 96 = C7).' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 5: Point/Sample Logic
            { type: 'knob', id: 'sampleFps', min: 1, max: 50, value: 15, log: false, suffix: ' FPS', step: 1, var: 'sampleRateFps', label: 'Sample Rate', info: 'SPEED: How many times per second to sample the audio and create points.' },
            { type: 'knob', id: 'pointLifetime', min: 5, max: 60, value: 10, log: false, suffix: ' s', step: 1, var: 'pointLifetime', label: 'Point Lifetime', info: 'VISUAL: How long a point stays on screen before fading out.' },
            { type: 'knob', id: 'maxPeaks', min: 1, max: 20, value: 2, log: false, suffix: '', step: 1, var: 'maxPeaks', label: 'Max Peaks', info: 'FILTER: The maximum number of points to create per frame. Lower values reduce noise.' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 6: Playback
            { type: 'knob', id: 'speed', min: 0.1, max: 5.0, value: 1.0, log: false, suffix: 'x', step: 0.1, var: 'playbackSpeed', label: 'Playback Speed', info: 'SPEED: The playback speed of the audio (1.0 = normal).' },
            { type: 'toggleKnob', id: 'loop', var: 'loopAudio', label: 'Loop Audio', info: 'Restarts the audio automatically when it ends.', value: window.loopAudio },
            { type: 'knob', id: 'autoRotateSpeed', min: -10.0, max: 10.0, value: 0.0, log: false, suffix: '', step: 0.1, var: 'autoRotateSpeed', label: 'Auto-Rotate Speed', info: 'VISUAL: Sets the speed of the auto-rotation. 0 = Off.' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 7: Color
            { type: 'knob', id: 'hueOffset', min: -0.5, max: 0.5, value: 0.0, log: false, suffix: '', step: 0.01, var: 'hueOffset', label: 'Base Hue Offset', info: 'Shifts the entire color wheel. Default 0.' },
            { type: 'knob', id: 'saturation', min: 0.0, max: 1.0, value: 1.0, log: false, suffix: '', step: 0.01, var: 'saturation', label: 'Base Saturation', info: 'Controls the intensity of the color (0=grey, 1=full color).' },
            { type: 'knob', id: 'lightness', min: 0.0, max: 1.0, value: 0.6, log: false, suffix: '', step: 0.01, var: 'lightness', label: 'Base Lightness', info: 'Controls the brightness of the color (0=black, 0.5=pure color, 1=white).' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 8: Bloom
            { type: 'knob', id: 'bloomThreshold', min: 0.0, max: 1.0, value: 0.04, log: false, suffix: '', step: 0.01, var: 'bloomThreshold', label: 'Bloom Threshold', info: 'The minimum brightness required for an object to start glowing.' },
            { type: 'knob', id: 'bloomStrength', min: 0.0, max: 3.0, value: 1.8, log: false, suffix: '', step: 0.1, var: 'bloomStrength', label: 'Bloom Strength', info: 'The intensity and power of the glow.' },
            { type: 'knob', id: 'bloomRadius', min: 0.0, max: 2.0, value: 0.7, log: false, suffix: '', step: 0.1, var: 'bloomRadius', label: 'Bloom Radius', info: 'How far the glow spreads from the bright object.' },

            /* { type: 'divider' }, // KALDIRILDI */

            // Group 9: Lines
            { type: 'checkbox', id: 'linesToggle', label: 'Show Tracking Lines', info: 'Shows the (faint grey) lines that track a single note over time.', var: 'enableLines', value: window.enableLines },
            { type: 'checkbox', id: 'simultaneousToggle', label: 'Connect Simultaneous Peaks', info: 'Connects different notes that are played at the same time (e.g., chords).', var: 'enableSimultaneousConnections', value: window.enableSimultaneousConnections },
            { type: 'knob', id: 'connectionDistance', min: 5, max: 500, value: 457, log: false, suffix: '', step: 1, var: 'connectionDistance', label: 'Connection Distance', info: 'The maximum 3D distance between two simultaneous notes to draw a line.' }
        ];

        // UI ElemanlarÄ±
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const removeBtn = document.getElementById('removeBtn');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const statusEl = document.getElementById('status');
        const progressBar = document.getElementById('progressBar');
        const toggleUiBtn = document.getElementById('toggleUiBtn');
        const controlsPanel = document.getElementById('controls');
        const settingsContainer = document.getElementById('settingsContainer');
        const infoBtn = document.getElementById('infoBtn');
        const infoModal = document.getElementById('infoModal');
        const closeInfoBtn = document.getElementById('closeInfoBtn');
        
        // YENÄ°: Tooltip ElemanÄ±
        const tooltip = document.getElementById('tooltip');

        const infoFreq = document.getElementById('infoFreq');
        const infoAmp = document.getElementById('infoAmp');
        const infoTimbre = document.getElementById('infoTimbre');

        // DeÄŸiÅŸkenler
        let parametricBox, labelRenderer, bloomPass;
        let scene, camera, renderer, composer, controls;
        
        // Audio State
        let audioContext, analyser, dataArray, source;
        let isPlaying = false;
        let startTime = 0;
        let lastSampleTime = 0;
        const points = [];
        const lines = [];

        // YENÄ°: DÃ¼ÄŸme SÃ¼rÃ¼kleme DeÄŸiÅŸkenleri
        let isDragging = false;
        let currentKnob = null;
        let startY = 0;
        let startValue = 0;

        // YENÄ°: DeÄŸer formatlama
        function formatValue(value, config) {
            let displayValue;
            if (config.log) {
                displayValue = Math.pow(10, value);
            } else {
                displayValue = value;
            }

            let text;
            if (config.id === 'amplitudeThreshold') {
                text = (displayValue * 100).toFixed(1) + config.suffix;
            } else if (config.id === 'pitchRangeMin' || config.id === 'pitchRangeMax') {
                text = `${displayValue} (${getNoteName(displayValue)})`;
            } else {
                let decimals = (config.step && config.step < 1) ? 2 : 0;
                if (config.log) decimals = 2; // Logaritmik Ã¶lÃ§ekler her zaman 2 ondalÄ±k
                text = displayValue.toFixed(decimals) + config.suffix;
            }
            return text;
        }

        // YENÄ°: DÃ¼ÄŸme GÃ¼ncelleme Fonksiyonu
        function updateKnob(knobData, value) {
            const config = knobData.config;
            const knobEl = knobData.element.querySelector('.knob-icon');
            const valueEl = knobData.element.querySelector('.knob-value');
            const knobFillEl = knobData.element.querySelector('.knob-fill'); // YENÄ°: Dolguyu seÃ§

            // 1. JS DeÄŸiÅŸkenini GÃ¼ncelle
            let actualValue = value;
            if (config.log) {
                actualValue = Math.pow(10, value);
            }
            window[config.var] = actualValue;

            // 2. GÃ¶rsel DeÄŸeri GÃ¼ncelle
            valueEl.textContent = formatValue(value, config);

            // 3. Ä°KON DÃ–NDÃœRME (KALDIRILDI)
            const percent = (value - config.min) / (config.max - config.min);
            // const rotation = -135 + (percent * 270); // -135 ile +135 derece arasÄ±
            // knobEl.style.transform = `rotate(${rotation}deg)`; // KALDIRILDI

            // YENÄ°: Dolgu YÃ¼ksekliÄŸini Ayarla
            if (knobFillEl) knobFillEl.style.height = (percent * 100) + '%';


            // 4. Ä°lgili JS Fonksiyonunu Tetikle
            switch(config.var) {
                case 'xAxisScale':
                case 'verticalScale':
                case 'zAxisScale':
                case 'minFrequency':
                case 'maxFrequency':
                case 'amplitudeThreshold':
                case 'harmonicSensitivity':
                case 'xAxisSensibility':
                case 'yAxisSensibility':
                    updateAllPositions();
                    break;
                case 'pointScale':
                    updateAllPositions(); // PozisyonlarÄ± ve Ã¶lÃ§eÄŸi gÃ¼nceller
                    break;
                case 'hueOffset':
                case 'saturation':
                case 'lightness':
                    updateAllColors();
                    break;
                case 'bloomThreshold':
                    if (bloomPass) bloomPass.threshold = actualValue;
                    break;
                case 'bloomStrength':
                    if (bloomPass) bloomPass.strength = actualValue;
                    break;
                case 'bloomRadius':
                    if (bloomPass) bloomPass.radius = actualValue;
                    break;
                case 'playbackSpeed':
                     if (source) source.playbackRate.setValueAtTime(actualValue, audioContext.currentTime);
                    break;
                case 'pointLifetime':
                    points.forEach(p => { p.lifetime = actualValue; p.initialLifetime = actualValue; });
                    break;
                // DiÄŸerleri (maxPeaks, sampleRateFps, vb.) sampleAudio() iÃ§inde zaten okunuyor
            }
        }

        // YENÄ°: DÃ¼ÄŸme SÃ¼rÃ¼kleme OlaylarÄ±
        function onKnobMouseDown(e) {
            if (!e.currentTarget.knobData) return;
            isDragging = true;
            currentKnob = e.currentTarget.knobData;
            startY = e.clientY;
            startValue = currentKnob.currentValue;
            document.body.style.cursor = 'ns-resize';
            e.preventDefault();
        }

        function onKnobMouseMove(e) {
            if (!isDragging || !currentKnob) return;

            const deltaY = startY - e.clientY; // YukarÄ± sÃ¼rÃ¼kle = pozitif
            const config = currentKnob.config;
            const range = config.max - config.min;
            const sensitivity = range / 200; // 200px sÃ¼rÃ¼kleme = tam aralÄ±k

            let newValue = startValue + (deltaY * sensitivity);
            newValue = Math.max(config.min, Math.min(config.max, newValue)); // Clamp
            
            if (config.step) {
                newValue = Math.round(newValue / config.step) * config.step;
            }

            if (newValue !== currentKnob.currentValue) {
                currentKnob.currentValue = newValue;
                updateKnob(currentKnob, newValue);
            }
            e.preventDefault();
        }

        function onKnobMouseUp(e) {
            isDragging = false;
            currentKnob = null;
            document.body.style.cursor = 'default';
            e.preventDefault();
        }

        // YENÄ°: Tooltip GÃ¶sterme/Gizleme
        function showTooltip(element) {
            const infoText = element.dataset.info;
            if (!infoText) return;

            tooltip.textContent = infoText;
            tooltip.style.display = 'block';

            const rect = element.getBoundingClientRect();
            // Panelin solunda gÃ¶ster
            tooltip.style.left = (rect.left - tooltip.offsetWidth - 10) + 'px';
            tooltip.style.top = (rect.top + (rect.height / 2) - (tooltip.offsetHeight / 2)) + 'px';
        }

        // YENÄ°: Tooltip Gizleme Fonksiyonu (EKSÄ°KTÄ°)
        function hideTooltip() {
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        // YENÄ°: DÃ¼ÄŸmeleri Dinamik Olarak OluÅŸtur (Tek Panel)
        function createKnobs() {
            const panel = document.getElementById('settingsContainer');
            panel.innerHTML = ''; // Paneli temizle

            ALL_CONTROLS_CONFIG.forEach(config => {
                if (config.type === 'knob') {
                    panel.appendChild(createKnobElement(config));
                } else if (config.type === 'toggleKnob') {
                    panel.appendChild(createToggleKnobElement(config));
                } else if (config.type === 'checkbox') {
                    panel.appendChild(createCheckboxElement(config));
                } /* else if (config.type === 'divider') { // KALDIRILDI
                    panel.appendChild(createDividerElement());
                } */
            });

            // Olay dinleyicilerini global olarak ayarla
            document.addEventListener('mousemove', onKnobMouseMove);
            document.addEventListener('mouseup', onKnobMouseUp);
        }

        function createKnobElement(config) {
            const container = document.createElement('div');
            container.className = 'knob-container';

            const knob = document.createElement('div');
            knob.className = 'knob';
            
            // YENÄ°: Dolguyu oluÅŸtur ve ekle (ikondan Ã¶nce)
            const knobFill = document.createElement('div');
            knobFill.className = 'knob-fill';
            knob.appendChild(knobFill);

            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('class', 'knob-icon');
            icon.setAttribute('viewBox', '0 0 24 24');
            icon.setAttribute('fill', 'none');
            icon.innerHTML = ICONS[config.id] || ICONS['pointScale']; // VarsayÄ±lan ikon
            knob.appendChild(icon);

            const label = document.createElement('span');
            label.className = 'knob-label';
            label.textContent = config.label;
            label.dataset.info = config.info;
            // YENÄ°: Tooltip event'leri
            label.addEventListener('mouseover', () => showTooltip(label));
            label.addEventListener('mouseout', hideTooltip);


            const value = document.createElement('span');
            value.className = 'knob-value';
            
            container.appendChild(knob);
            container.appendChild(label);
            container.appendChild(value);

            // Veriyi Ã¶ÄŸeye baÄŸla
            const knobData = {
                element: container,
                config: config,
                currentValue: config.value
            };
            knob.knobData = knobData; // HATA DÃœZELTME: Veriyi 'container' yerine 'knob'a baÄŸla
            
            // Olay dinleyicisi
            knob.addEventListener('mousedown', onKnobMouseDown);

            // BaÅŸlangÄ±Ã§ deÄŸerini ayarla
            updateKnob(knobData, config.value);

            return container;
        }

        // YENÄ°: Dairesel Toggle DÃ¼ÄŸmesi OluÅŸturucu
        function createToggleKnobElement(config) {
            const container = document.createElement('div');
            container.className = 'knob-container';

            const knob = document.createElement('div');
            knob.className = 'knob';
            knob.style.cursor = 'pointer'; // TÄ±klama imleci
            
            const knobFill = document.createElement('div');
            knobFill.className = 'knob-fill';
            knob.appendChild(knobFill);

            const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            icon.setAttribute('class', 'knob-icon');
            icon.setAttribute('viewBox', '0 0 24 24');
            icon.setAttribute('fill', 'none');
            icon.innerHTML = ICONS[config.id] || ICONS['loop'];
            knob.appendChild(icon);

            const label = document.createElement('span');
            label.className = 'knob-label';
            label.textContent = config.label;
            label.dataset.info = config.info;
            label.addEventListener('mouseover', () => showTooltip(label));
            label.addEventListener('mouseout', hideTooltip);

            const valueEl = document.createElement('span');
            valueEl.className = 'knob-value';
            
            container.appendChild(knob);
            container.appendChild(label);
            container.appendChild(valueEl);

            const knobData = {
                element: container,
                config: config,
                currentValue: config.value
            };
            knob.knobData = knobData;
            
            // TÄ±klama olayÄ± (sÃ¼rÃ¼kleme deÄŸil)
            knob.addEventListener('click', (e) => {
                const data = e.currentTarget.knobData;
                const newValue = !data.currentValue;
                data.currentValue = newValue;
                updateToggleKnob(data, newValue);
            });

            updateToggleKnob(knobData, config.value); // BaÅŸlangÄ±Ã§ deÄŸerini ayarla
            return container;
        }

        // YENÄ°: Dairesel Toggle GÃ¼ncelleyici
        function updateToggleKnob(knobData, value) {
            const config = knobData.config;
            const valueEl = knobData.element.querySelector('.knob-value');
            const knobFillEl = knobData.element.querySelector('.knob-fill');
            
            window[config.var] = value;
            valueEl.textContent = value ? 'YES' : 'NO';
            knobFillEl.style.height = value ? '100%' : '0%';

            if (config.var === 'loopAudio' && source) {
                source.loop = value;
            }
        }


        // YENÄ°: Checkbox OluÅŸturucu (Refactor)
        function createCheckboxElement(config) {
            const container = document.createElement('div');
            container.className = 'checkbox-group';

            const labelWrapper = document.createElement('div');
            labelWrapper.className = 'label-wrapper';

            const labelEl = document.createElement('label');
            labelEl.setAttribute('for', config.id);
            labelEl.textContent = config.label;
            labelEl.dataset.info = config.info;
            labelEl.addEventListener('mouseover', () => showTooltip(labelEl));
            labelEl.addEventListener('mouseout', hideTooltip);

            labelWrapper.appendChild(labelEl);
            container.appendChild(labelWrapper);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = config.id;
            checkbox.checked = config.value; // VarsayÄ±lan deÄŸeri config'den al
            
            // Genel event listener
            checkbox.addEventListener('change', () => { 
                window[config.var] = checkbox.checked; 
            });

            container.appendChild(checkbox);
            return container;
        }

        /* YENÄ°: AyÄ±rÄ±cÄ± OluÅŸturucu (KALDIRILDI)
        function createDividerElement() {
            const div = document.createElement('div');
            div.className = 'settings-divider';
            return div;
        }
        */

        
        // Scene Setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha true
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0); // Åžeffaf arka plan
        document.getElementById('container').appendChild(renderer.domElement);
        
        camera.position.set(25, 15, 35);
        camera.lookAt(0, 0, 0);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = false; // VarsayÄ±lan
        
        labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.getElementById('container').appendChild(labelRenderer.domElement);

        // Post-processing (Bloom)
        composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            window.bloomStrength, window.bloomRadius, window.bloomThreshold
        );
        composer.addPass(bloomPass);

        // BaÅŸlatma
        initParametricBox();
        createKnobs(); // YENÄ°: DÃ¼ÄŸmeleri oluÅŸtur
        
        // KÃ¼p (Sadece Ã§izgiler)
        function initParametricBox() {
            parametricBox = new THREE.Group();
            const boxGeom = new THREE.BoxGeometry(BASE_X_WIDTH, BASE_Y_HEIGHT, BASE_Z_DEPTH);
            const boxEdges = new THREE.EdgesGeometry(boxGeom);
            const boxMat = new THREE.LineBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.3, 
                linewidth: 1 // Bu 1 olarak kalmalÄ±
            });
            const boxLines = new THREE.LineSegments(boxEdges, boxMat);
            parametricBox.add(boxLines);
            scene.add(parametricBox);
        }
        
        // KÃ¼p Grubunu (3 eksende) Ã¶lÃ§ekler
        function updateBoxScale() {
            if (parametricBox) {
                parametricBox.scale.set(window.xAxisScale, window.verticalScale, window.zAxisScale);
            }
        }
        
        // TÃ¼m nokta ve Ã§izgilerin pozisyonunu (3 eksende) gÃ¼nceller
        function updateAllPositions() {
            updateBoxScale();
            for (const point of points) {
                const logMinFreq = Math.log10(window.minFrequency > 0 ? window.minFrequency : 1);
                const logMaxFreq = Math.log10(window.maxFrequency);
                const logCurrentFreq = Math.log10(point.frequency);
                let logNormalizedFreq = (logCurrentFreq - logMinFreq) / (logMaxFreq - logMinFreq);
                logNormalizedFreq = Math.min(Math.max(logNormalizedFreq, 0), 1);
                logNormalizedFreq = Math.pow(logNormalizedFreq, window.xAxisSensibility); 
                point.x_norm = logNormalizedFreq - 0.5;
                
                const ampRange = 1.0 - window.amplitudeThreshold;
                let ampNormalized = (point.amplitude - window.amplitudeThreshold) / ampRange;
                ampNormalized = Math.min(Math.max(ampNormalized, 0), 1);
                ampNormalized = Math.pow(ampNormalized, window.yAxisSensibility);
                point.y_norm = ampNormalized - 0.5;
                
                let timbreNormalized = point.harmonicRichness * window.harmonicSensitivity;
                timbreNormalized = Math.min(Math.max(timbreNormalized, 0), 1);
                point.z_norm = timbreNormalized - 0.5;
                
                point.mesh.position.set(
                    point.x_norm * BASE_X_WIDTH * window.xAxisScale,
                    point.y_norm * BASE_Y_HEIGHT * window.verticalScale,
                    point.z_norm * BASE_Z_DEPTH * window.zAxisScale
                );
                
                // Ã–lÃ§eÄŸi de burada gÃ¼ncelle
                const opacity = Math.max(0, point.lifetime / point.initialLifetime);
                const ampScale = 0.2 + (point.amplitude * 0.8);
                const finalScale = window.pointScale * ampScale * (opacity * 0.5 + 0.5);
                point.mesh.scale.set(finalScale, finalScale, finalScale);
            }
            
            for (const lineInfo of lines) {
                if (lineInfo.startPoint && lineInfo.endPoint && points.includes(lineInfo.startPoint) && points.includes(lineInfo.endPoint)) {
                    const positions = lineInfo.line.geometry.attributes.position;
                    positions.setXYZ(0, lineInfo.startPoint.mesh.position.x, lineInfo.startPoint.mesh.position.y, lineInfo.startPoint.mesh.position.z);
                    positions.setXYZ(1, lineInfo.endPoint.mesh.position.x, lineInfo.endPoint.mesh.position.y, lineInfo.endPoint.mesh.position.z);
                    positions.needsUpdate = true;
                    lineInfo.line.geometry.computeBoundingSphere();
                }
            }
        }

        // TÃ¼m mevcut noktalarÄ±n ve Ã§izgilerin renklerini gÃ¼nceller
        function updateAllColors() {
            for (const point of points) {
                const newColor = getColorByPitchClass(point.pitchClass);
                point.color.copy(newColor);
                point.mesh.material.color.copy(newColor);
            }
            for (const lineInfo of lines) {
                if (lineInfo.type === 'harmonic' && lineInfo.startPoint) {
                    lineInfo.line.material.color.copy(lineInfo.startPoint.color);
                }
            }
        }

        // Renk Hesaplama (Nota SÄ±nÄ±fÄ±na + HSL AyarlarÄ±na GÃ¶re)
        function getColorByPitchClass(pitchClass) { 
            let hue = (pitchClass % 12) / 12.0;
            hue += window.hueOffset; 
            hue = (hue % 1.0 + 1.0) % 1.0;
            const color = new THREE.Color();
            color.setHSL(hue, window.saturation, window.lightness); 
            return color;
        }

        // Tepe NoktalarÄ±nÄ± ve Harmonik ZenginliÄŸi Bulma
        function getAllActivePeaks() {
            if (!analyser || !isPlaying) return [];
            
            analyser.getByteFrequencyData(dataArray);
            
            const sampleRate = audioContext.sampleRate;
            const binCount = analyser.frequencyBinCount;
            const binFrequency = sampleRate / FFT_SIZE;
            const harmonicSearchWidth = 3;
            
            const candidatePeaks = [];
            for (let i = 5; i < binCount - 5; i++) {
                const amplitude = dataArray[i] / 255.0;
                if (amplitude < window.amplitudeThreshold) continue;
                
                const frequency = i * binFrequency;
                if (frequency < window.minFrequency || frequency > window.maxFrequency) continue;
                
                let isLocalMax = true;
                for (let j = 1; j <= 3; j++) {
                    if (amplitude < dataArray[i - j] / 255.0 || amplitude < dataArray[i + j] / 255.0) {
                        isLocalMax = false;
                        break;
                    }
                }
                if (!isLocalMax) continue;
                
                const alpha = dataArray[i - 1] / 255.0;
                const beta = dataArray[i] / 255.0;
                const gamma = dataArray[i + 1] / 255.0;
                const p = 0.5 * (alpha - gamma) / (alpha - 2.0 * beta + gamma);
                const preciseFrequency = (i + p) * binFrequency;
                const fundamentalBin = i + p;
                
                const midiNote = 12 * Math.log2(preciseFrequency / A4_FREQ) + 69;
                if (midiNote < window.pitchRangeMin || midiNote > window.pitchRangeMax) continue;
                
                const pitchClass = Math.round(midiNote) % 12;
                
                let harmonicSum = 0;
                for (let h = 2; h <= 4; h++) {
                    const targetBin = Math.round(fundamentalBin * h);
                    let maxAmpInWindow = 0;
                    for (let w = -harmonicSearchWidth; w <= harmonicSearchWidth; w++) {
                        const bin = targetBin + w;
                        if (bin > 0 && bin < binCount) {
                            maxAmpInWindow = Math.max(maxAmpInWindow, dataArray[bin] / 255.0);
                        }
                    }
                    harmonicSum += Math.min(maxAmpInWindow, amplitude);
                }
                const harmonicRichness = (amplitude > 0.01) ? harmonicSum / amplitude : 0;
                
                candidatePeaks.push({
                    frequency: preciseFrequency,
                    amplitude: amplitude,
                    bin: i,
                    midiNote: midiNote,
                    pitchClass: pitchClass,
                    harmonicRichness: harmonicRichness
                });
                
                i += 3; 
            }
            
            candidatePeaks.sort((a, b) => b.amplitude - a.amplitude);
            const filteredPeaks = [];
            for (const peak of candidatePeaks) {
                let isMasked = false;
                for (const filteredPeak of filteredPeaks) {
                    if (Math.abs(peak.frequency - filteredPeak.frequency) < spectralMaskingHz) {
                        isMasked = true;
                        break;
                    }
                }
                if (!isMasked) {
                    filteredPeaks.push(peak);
                    if (filteredPeaks.length >= window.maxPeaks) break;
                }
            }
            return filteredPeaks;
        }

        // Nokta OluÅŸturma
        function createPoint(x, y, z, color, amplitude, frequency, emissionTime, midiNote, harmonicRichness, pitchClass) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            
            const baseScale = window.pointScale;
            const amplitudeScale = 0.2 + (amplitude * 0.8);
            const finalScale = baseScale * amplitudeScale;
            mesh.scale.set(finalScale, finalScale, finalScale);
            
            scene.add(mesh);
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'label';
            labelDiv.style.display = 'none';
            document.body.appendChild(labelDiv);
            
            const point = {
                position: mesh.position,
                color: color.clone(),
                lifetime: window.pointLifetime,
                initialLifetime: window.pointLifetime,
                mesh: mesh,
                emissionTime: emissionTime,
                amplitude: amplitude,
                frequency: frequency,
                midiNote: midiNote,
                pitchClass: pitchClass,
                harmonicRichness: harmonicRichness,
                label: labelDiv,
                x_norm: 0,
                y_norm: 0,
                z_norm: 0,
                baseScale: baseScale
            };
            points.push(point);
            return point;
        }

        // Ã‡izgi OluÅŸturma (KALINLIK KALDIRILDI)
        function createLine(startPoint, endPoint, color, type = 'track') {
            let lineVisible, lineColor, lineOpacity;
            if (type === 'track') {
                lineVisible = window.enableLines;
                lineColor = 0xAAAAAA;
                lineOpacity = 0.5;
            } else { // 'harmonic'
                lineVisible = window.enableSimultaneousConnections;
                lineColor = color;
                lineOpacity = 0.7;
            }
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                startPoint.position,
                endPoint.position
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({
                color: lineColor,
                transparent: true,
                opacity: lineOpacity
                // linewidth kaldÄ±rÄ±ldÄ±
            });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            line.visible = lineVisible;
            
            scene.add(line);
            
            lines.push({
                line: line,
                startPoint: startPoint,
                endPoint: endPoint,
                type: type
            });
        }

        // Ses Ã–rnekleme
        function sampleAudio() {
            if (!isPlaying || !audioContext) return;
            
            const currentTime = audioContext.currentTime - startTime;
            
            if (currentTime - lastSampleTime >= 1.0 / window.sampleRateFps) {
                const sampleTime = currentTime;
                lastSampleTime = sampleTime;
                
                const allPeaks = getAllActivePeaks();
                const newPeakData = [];
                
                if (allPeaks.length > 0) {
                    const mainPeak = allPeaks[0];
                    infoFreq.textContent = `${mainPeak.frequency.toFixed(0)} Hz`;
                    infoAmp.textContent = `${(mainPeak.amplitude * 100).toFixed(1)}%`;
                    infoTimbre.textContent = `${mainPeak.harmonicRichness.toFixed(2)}`;
                } else {
                    infoFreq.textContent = "--"; infoAmp.textContent = "--"; infoTimbre.textContent = "--";
                }

                allPeaks.forEach(data => {
                    const logMinFreq = Math.log10(window.minFrequency > 0 ? window.minFrequency : 1);
                    const logMaxFreq = Math.log10(window.maxFrequency);
                    const logCurrentFreq = Math.log10(data.frequency);
                    let logNormalizedFreq = (logCurrentFreq - logMinFreq) / (logMaxFreq - logMinFreq);
                    logNormalizedFreq = Math.min(Math.max(logNormalizedFreq, 0), 1);
                    logNormalizedFreq = Math.pow(logNormalizedFreq, window.xAxisSensibility);
                    const x_norm = logNormalizedFreq - 0.5;
                    
                    const ampRange = 1.0 - window.amplitudeThreshold;
                    let ampNormalized = (data.amplitude - window.amplitudeThreshold) / ampRange;
                    ampNormalized = Math.min(Math.max(ampNormalized, 0), 1);
                    ampNormalized = Math.pow(ampNormalized, window.yAxisSensibility);
                    const y_norm = ampNormalized - 0.5;
                    
                    let timbreNormalized = data.harmonicRichness * window.harmonicSensitivity;
                    timbreNormalized = Math.min(Math.max(timbreNormalized, 0), 1);
                    const z_norm = timbreNormalized - 0.5;
                    
                    const color = getColorByPitchClass(data.pitchClass);
                    
                    let bestMatch = null;
                    let minNoteDiff = peakTrackingTolerance;
                    let bestMatchIndex = -1;
                    for (let i = 0; i < previousPeaks.length; i++) {
                        const prevPeak = previousPeaks[i];
                        if (prevPeak.matched) continue;
                        const noteDiff = Math.abs(data.midiNote - prevPeak.midiNote);
                        if (noteDiff < minNoteDiff) {
                            minNoteDiff = noteDiff;
                            bestMatch = prevPeak;
                            bestMatchIndex = i;
                        }
                    }
                    
                    const x = x_norm * BASE_X_WIDTH * window.xAxisScale;
                    const y = y_norm * BASE_Y_HEIGHT * window.verticalScale;
                    const z = z_norm * BASE_Z_DEPTH * window.zAxisScale;
                    
                    const newPoint = createPoint(x, y, z, color, data.amplitude, data.frequency, sampleTime, data.midiNote, data.harmonicRichness, data.pitchClass);
                    
                    newPoint.x_norm = x_norm;
                    newPoint.y_norm = y_norm;
                    newPoint.z_norm = z_norm;
                    
                    if (bestMatch) {
                        createLine(bestMatch.point, newPoint, color, 'track');
                        previousPeaks[bestMatchIndex].matched = true;
                    }
                    
                    newPeakData.push({
                        frequency: data.frequency,
                        midiNote: data.midiNote,
                        point: newPoint,
                        matched: false
                    });
                });
                
                if (window.enableSimultaneousConnections) {
                    for (let i = 0; i < newPeakData.length; i++) {
                        for (let j = i + 1; j < newPeakData.length; j++) {
                            const p1 = newPeakData[i].point;
                            const p2 = newPeakData[j].point;
                            const dist = p1.position.distanceTo(p2.position);
                            
                            if (dist < window.connectionDistance) {
                                createLine(p1, p2, p1.color, 'harmonic');
                            }
                        }
                    }
                }
                
                previousPeaks = newPeakData;
            }
        }
        // NoktalarÄ± GÃ¼ncelleme
        function updatePointsAndLines(deltaTime) {
            
            for (let i = points.length - 1; i >= 0; i--) {
                const point = points[i];
                point.lifetime -= deltaTime;
                
                const opacity = Math.max(0, point.lifetime / point.initialLifetime);
                point.mesh.material.opacity = opacity;
                
                const ampScale = 0.2 + (point.amplitude * 0.8);
                const finalScale = point.baseScale * ampScale * (opacity * 0.5 + 0.5);
                point.mesh.scale.set(finalScale, finalScale, finalScale);
                
                if (point.lifetime <= 0) {
                    scene.remove(point.mesh);
                    point.mesh.geometry.dispose();
                    point.mesh.material.dispose();
                    if(point.label.parentNode) document.body.removeChild(point.label);
                    const removedPoint = points.splice(i, 1)[0];
                    for (let j = previousPeaks.length - 1; j >= 0; j--) {
                        if (previousPeaks[j].point === removedPoint) {
                            previousPeaks.splice(j, 1);
                            break;
                        }
                    }
                }
            }
            
            for (let i = lines.length - 1; i >= 0; i--) {
                const lineInfo = lines[i];
                if (points.includes(lineInfo.startPoint) && points.includes(lineInfo.endPoint)) {
                    if (lineInfo.type === 'track') {
                        lineInfo.line.visible = window.enableLines;
                    } else if (lineInfo.type === 'harmonic') {
                        lineInfo.line.visible = window.enableSimultaneousConnections;
                    }
                    
                    const minOpacity = Math.min(
                        lineInfo.startPoint.mesh.material.opacity,
                        lineInfo.endPoint.mesh.material.opacity
                    );
                    lineInfo.line.material.opacity = minOpacity * (lineInfo.type === 'track' ? 0.5 : 0.7);
                } else {
                    scene.remove(lineInfo.line);
                    lineInfo.line.geometry.dispose();
                    lineInfo.line.material.dispose();
                    lines.splice(i, 1);
                }
            }
        }
        // Etiketleri GÃ¼ncelleme
        function updateLabels() {
            points.forEach(point => {
                // ... (Etiket mantÄ±ÄŸÄ± deÄŸiÅŸmedi, ancak bu sÃ¼rÃ¼mde Ã§aÄŸrÄ±lmÄ±yor) ...
            });
        }
        
        // Ses motorunu durdurma (reset)
        async function resetAudio() {
             if (isPlaying && source) {
                 source.onended = null;
                 source.stop();
            }
            if (source) source.disconnect();
            if (analyser) analyser.disconnect();
            if (audioContext && audioContext.state !== 'closed') {
                 await audioContext.close();
            }
            source = null;
            analyser = null;
            
            points.forEach(p => {
                scene.remove(p.mesh);
                if (p.label && p.label.parentNode) {
                    document.body.removeChild(p.label);
                }
            });
            lines.forEach(l => scene.remove(l.line));
            points.length = 0;
            lines.length = 0;
            previousPeaks.length = 0;
            
            isPlaying = false;
            progressBar.style.width = '0%';
            statusEl.textContent = 'Load a file or paste a URL';
            playBtn.disabled = false;
            stopBtn.style.display = 'none';
            playBtn.style.display = 'block';
            infoFreq.textContent = "--";
            infoAmp.textContent = "--";
            infoTimbre.textContent = "--";
        }
        // Ses YÃ¼kleme
        async function initAudio(sourceType) {
            await resetAudio();
            statusEl.textContent = 'Loading...';
            playBtn.disabled = true;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0.75;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                let audioBuffer;
                
                let sourceName = 'audio';
                if (sourceType === 'file') {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    sourceName = file.name;
                } else if (sourceType === 'url') {
                    statusEl.textContent = 'Fetching from URL...';
                    const response = await fetch(urlInput.value.trim());
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    sourceName = 'URL';
                }
                else if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    const arrayBuffer = await file.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    sourceName = file.name;
                } else if (urlInput.value.trim()) {
                    statusEl.textContent = 'Fetching from URL...';
                    const response = await fetch(urlInput.value.trim());
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    sourceName = 'URL';
                } else {
                    statusEl.textContent = 'No file or URL provided';
                    playBtn.disabled = false;
                    return;
                }
                statusEl.textContent = `Playing: ${sourceName}`;
                source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.loop = window.loopAudio;
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                source.playbackRate.setValueAtTime(window.playbackSpeed, 0);
                source.start(0);
                startTime = audioContext.currentTime;
                lastSampleTime = 0;
                isPlaying = true;
                playBtn.style.display = 'none';
                stopBtn.style.display = 'block';
                stopBtn.textContent = 'Stop';
                playBtn.disabled = false;
                
                source.onended = () => {
                    if (isPlaying) { 
                        resetAudio();
                        statusEl.textContent = 'Finished. Load new or Play again.';
                    }
                };
            } catch (error) {
                statusEl.textContent = 'Audio loading error: ' + error.message;
                console.error(error);
                playBtn.disabled = false;
                stopBtn.style.display = 'none';
                playBtn.style.display = 'block';
            }
        }

        // Sahne IÅŸÄ±klarÄ±
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.2);
        scene.add(ambientLight);
        
        // Ana Render DÃ¶ngÃ¼sÃ¼
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            lastTime = currentTime;
            
            if (isPlaying) {
                sampleAudio();
                updatePointsAndLines(deltaTime);
            }
            
            // updateLabels(); // Etiketler kaldÄ±rÄ±ldÄ±
            
            if (isPlaying && source && source.buffer) {
                const elapsedTime = audioContext.currentTime - startTime;
                const duration = source.buffer.duration;
                const progress = Math.min(elapsedTime / duration, 1);
                progressBar.style.width = (progress * 100) + '%';
            }
            
            if (controls.autoRotate) {
                controls.autoRotateSpeed = window.autoRotateSpeed;
            }
            
            controls.update();
            composer.render();
            labelRenderer.render(scene, camera);
        }

        // Ana Event Listeners
        playBtn.addEventListener('click', () => initAudio());
        stopBtn.addEventListener('click', resetAudio);
        
        removeBtn.addEventListener('click', () => {
            resetAudio();
            fileInput.value = '';
            urlInput.value = '';
            statusEl.textContent = 'Load a file or paste a URL';
        });
        fileInput.addEventListener('change', () => {
            if (fileInput.files.length > 0) {
                urlInput.value = '';
                initAudio('file');
            }
        });
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                if(urlInput.value.trim()) {
                    fileInput.value = '';
                    initAudio('url');
                }
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // UI Gizleme
        let uiVisible = true;
        toggleUiBtn.addEventListener('click', () => {
            uiVisible = !uiVisible;
            const displayValue = uiVisible ? 'flex' : 'none';
            // const blockDisplayValue = uiVisible ? 'block' : 'none'; // blockDisplayValue kaldÄ±rÄ±ldÄ±
            
            controlsPanel.style.display = displayValue;
            settingsContainer.style.display = uiVisible ? 'flex' : 'none'; // .settings-panel artÄ±k 'flex' kullanÄ±yor
            
            if (parametricBox) parametricBox.visible = uiVisible;
            
            toggleUiBtn.textContent = uiVisible ? 'Hide UI' : 'Show UI';
        });

        // Info Modal Kontrolleri
        infoBtn.addEventListener('click', () => {
            infoModal.style.display = 'flex';
        });
        closeInfoBtn.addEventListener('click', () => {
            infoModal.style.display = 'none';
        });

        // Global tÄ±klama ile pop-up'larÄ± kapat
        document.body.addEventListener('click', (e) => {
            // Ana info modal'Ä±
            if (infoModal.style.display === 'flex' && e.target === infoModal) {
                infoModal.style.display = 'none';
            }
        }, true); // Use capture phase

        // YENÄ°: DÃ¼ÄŸme SÃ¼rÃ¼kleme iÃ§in global listener'lar (createKnobs iÃ§ine taÅŸÄ±ndÄ±)
        // document.addEventListener('mousemove', onKnobMouseMove);
        // document.addEventListener('mouseup', onKnobMouseUp);

        // BaÅŸlangÄ±Ã§
        animate();
    </script>
</body>
</html>
